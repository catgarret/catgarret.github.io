<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>로컬 폰트 PostScript 이름 확인기</title>
    <!-- Tailwind CSS 로드 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Inter 폰트 로드 */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        /* 스크롤바 스타일링 */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        ::-webkit-scrollbar-thumb {
            background-color: #9ca3af; /* gray-400 */
            border-radius: 3px;
        }
        ::-webkit-scrollbar-track {
            background-color: #f3f4f6; /* gray-100 */
        }
        /* 알림창 스타일 */
        #toast {
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="flex flex-col md:flex-row h-screen">
        
        <!-- 왼쪽: 폰트 목록 및 검색 -->
        <aside class="w-full md:w-1/3 lg:w-1/4 h-1/2 md:h-screen bg-white shadow-lg flex flex-col">
            <div class="p-4 border-b">
                <h2 class="text-xl font-semibold text-gray-900">설치된 폰트 목록</h2>
                <input type="text" id="searchInput" placeholder="폰트 이름 검색... (예: San)" class="w-full mt-3 p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
            </div>
            
            <!-- 폰트 목록 스크롤 영역 -->
            <div id="fontListContainer" class="flex-1 overflow-y-auto p-2">
                <ul id="fontList" class="divide-y divide-gray-200">
                    <!-- 폰트 목록이 여기에 동적으로 추가됩니다 -->
                </ul>
            </div>

            <!-- 상태 메시지 영역 -->
            <div id="statusMessage" class="p-4 border-t bg-gray-50 text-center">
                <p class="text-gray-600">폰트 목록을 불러오는 중...</p>
            </div>
        </aside>

        <!-- 오른쪽: 폰트 상세 정보 -->
        <main class="flex-1 h-1/2 md:h-screen overflow-y-auto p-6 md:p-10">
            <div id="welcomeMessage" class="h-full flex flex-col items-center justify-center text-center text-gray-500">
                <svg xmlns="http://www.w3.org/2000/svg" class="w-16 h-16" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
                </svg>
                <h2 class="text-2xl font-semibold mt-4">폰트 확인기</h2>
                <p class="mt-2 max-w-md">왼쪽 목록에서 폰트 패밀리를 선택하면 상세 정보(PostScript 이름, Weight 등)가 여기에 표시됩니다.</p>
                
                <!-- API 지원 불가 시 메시지 -->
                <div id="apiError" class="hidden mt-6 p-4 bg-red-100 text-red-700 rounded-lg">
                    <p class="font-bold">호환성 오류</p>
                    <p class="mt-1">이 브라우저는 '로컬 폰트 접근 API'를 지원하지 않습니다.<br>PostScript 이름을 확인하려면 <strong class="font-semibold">최신 버전의 Chrome 또는 Edge 브라우저</strong>를 사용해 주세요.</p>
                </div>
            </div>

            <div id="fontDetails" class="hidden">
                <!-- 1. 폰트 미리보기 -->
                <section>
                    <h3 class="text-2xl font-bold text-gray-900" id="fontFamilyName">Font Family</h3>
                    <div id="fontPreview" class="mt-4 p-6 bg-white rounded-xl shadow-inner overflow-hidden text-3xl md:text-5xl" style="font-family: 'Inter';">
                        가나다라 ABC 123
                    </div>
                </section>

                <!-- 2. PostScript 이름 및 웨이트 -->
                <section class="mt-8">
                    <h4 class="text-xl font-semibold text-gray-800">PostScript 이름 및 상세 정보</h4>
                    <p class="text-sm text-gray-600 mt-1">이름을 클릭하면 클립보드에 복사됩니다.</p>
                    
                    <div id="postscriptList" class="mt-4 grid grid-cols-1 lg:grid-cols-2 gap-4">
                        <!-- PostScript 이름 카드가 여기에 동적으로 추가됩니다 -->
                    </div>
                </section>
            </div>
        </main>
    </div>

    <!-- 클립보드 복사 알림창 (Toast) -->
    <div id="toast" class="fixed bottom-10 right-10 bg-gray-900 text-white px-4 py-2 rounded-lg shadow-lg opacity-0 transform translate-y-2">
        클립보드에 복사되었습니다!
    </div>

    <script>
        // 전역 변수
        const fontListEl = document.getElementById('fontList');
        const searchInputEl = document.getElementById('searchInput');
        const statusMessageEl = document.getElementById('statusMessage');
        const welcomeMessageEl = document.getElementById('welcomeMessage');
        const apiErrorEl = document.getElementById('apiError');
        const fontDetailsEl = document.getElementById('fontDetails');
        const fontFamilyNameEl = document.getElementById('fontFamilyName');
        const fontPreviewEl = document.getElementById('fontPreview');
        const postscriptListEl = document.getElementById('postscriptList');
        const toastEl = document.getElementById('toast');
        
        let fontDataMap = new Map(); // 폰트 패밀리별로 폰트 데이터(weight, ps-name 등)를 그룹화
        let fontFamilies = []; // 폰트 패밀리 이름 목록 (검색용)

        /**
         * 페이지 로드 시 폰트 쿼리 실행
         */
        window.addEventListener('load', async () => {
            // 1. API 지원 여부 확인
            if (!('fonts' in navigator) || !('query' in navigator.fonts)) {
                statusMessageEl.innerHTML = '<p class="text-red-600 font-semibold">API 미지원</p>';
                welcomeMessageEl.classList.add('hidden'); // 환영 메시지 숨기기
                apiErrorEl.classList.remove('hidden'); // 에러 메시지 표시
                fontDetailsEl.innerHTML = '';
                fontListEl.innerHTML = '';
                return;
            }

            // 2. 폰트 쿼리 실행 (사용자 권한 요청)
            try {
                statusMessageEl.innerHTML = '<p class="text-blue-600">사용자 권한을 기다리는 중...</p>';
                const allFonts = await navigator.fonts.query();
                
                if (allFonts.length === 0) {
                    statusMessageEl.innerHTML = '<p class="text-gray-600">설치된 폰트를 찾을 수 없거나 권한이 거부되었습니다.</p>';
                    return;
                }

                statusMessageEl.innerHTML = '<p class="text-gray-600">폰트 데이터 처리 중...</p>';
                
                // 3. 폰트 데이터 그룹화 (가장 중요)
                // fontDataMap: { "Sandoll Gothic Neo1": [FontData, FontData, ...], "Inter": [...] }
                fontDataMap.clear();
                allFonts.forEach(fontData => {
                    const family = fontData.family;
                    if (!fontDataMap.has(family)) {
                        fontDataMap.set(family, []);
                    }
                    fontDataMap.get(family).push(fontData);
                });

                // 4. 폰트 패밀리 목록 생성 및 정렬
                fontFamilies = Array.from(fontDataMap.keys()).sort();
                
                // 5. 폰트 목록 렌더링
                renderFontList(fontFamilies);
                statusMessageEl.innerHTML = `<p class="text-green-600 font-semibold">${fontFamilies.length}개의 폰트 패밀리를 찾았습니다.</p>`;

            } catch (err) {
                console.error('폰트 접근 오류:', err);
                statusMessageEl.innerHTML = '<p class="text-red-600 font-semibold">폰트 접근 권한이 거부되었습니다.</p>';
                apiErrorEl.classList.remove('hidden');
            }
        });

        /**
         * 왼쪽 폰트 목록을 렌더링하는 함수
         * @param {string[]} families - 표시할 폰트 패밀리 이름 배열
         */
        function renderFontList(families) {
            fontListEl.innerHTML = ''; // 목록 비우기
            if (families.length === 0) {
                fontListEl.innerHTML = '<li class="p-3 text-center text-gray-500">검색 결과가 없습니다.</li>';
                return;
            }

            const fragment = document.createDocumentFragment();
            families.forEach(family => {
                const li = document.createElement('li');
                li.className = 'p-3 hover:bg-blue-50 cursor-pointer rounded-md transition-colors duration-150';
                li.textContent = family;
                li.dataset.fontFamily = family; // 데이터 속성에 폰트 이름 저장
                
                // 폰트 목록 클릭 이벤트
                li.addEventListener('click', () => handleFontSelect(family));
                fragment.appendChild(li);
            });
            fontListEl.appendChild(fragment);
        }

        /**
         * 폰트 검색 (자동완성) 이벤트
         */
        searchInputEl.addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase();
            if (!query) {
                renderFontList(fontFamilies); // 검색어가 없으면 전체 목록 표시
                return;
            }
            
            // 검색어(query)를 포함(includes)하는 폰트 패밀리만 필터링
            const filteredFamilies = fontFamilies.filter(family => 
                family.toLowerCase().includes(query)
            );
            renderFontList(filteredFamilies);
        });

        /**
         * 폰트 패밀리 선택 시 상세 정보 표시
         * @param {string} fontFamily - 선택된 폰트 패밀리 이름
         */
        function handleFontSelect(fontFamily) {
            // 1. 환영 메시지 숨기고 상세 정보 표시
            welcomeMessageEl.classList.add('hidden');
            fontDetailsEl.classList.remove('hidden');

            // 2. 폰트 미리보기 업데이트
            fontFamilyNameEl.textContent = fontFamily;
            fontPreviewEl.style.fontFamily = `"${fontFamily}"`; // 따옴표로 감싸기

            // 3. PostScript 이름 및 웨이트 목록 생성
            postscriptListEl.innerHTML = '';
            const fontVariants = fontDataMap.get(fontFamily) || [];

            // 웨이트(weight) 기준으로 정렬
            fontVariants.sort((a, b) => a.weight - b.weight);

            if (fontVariants.length === 0) {
                postscriptListEl.innerHTML = '<p class="text-gray-600">이 폰트 패밀리에 대한 상세 정보(PostScript)를 찾을 수 없습니다.</p>';
                return;
            }

            fontVariants.forEach(variant => {
                const card = document.createElement('div');
                card.className = 'bg-white p-4 rounded-lg shadow border border-gray-200';
                
                const psName = variant.postscriptName;
                const weight = variant.weight;
                const style = variant.style;

                card.innerHTML = `
                    <div class="flex justify-between items-center">
                        <span class="text-sm font-medium text-gray-500">PostScript Name</span>
                        <button data-ps-name="${psName}" class="copy-btn text-xs bg-gray-200 text-gray-700 px-2 py-1 rounded-md hover:bg-gray-300 transition-colors">복사</button>
                    </div>
                    <p class="mt-1 text-lg font-semibold text-blue-600 cursor-pointer copy-text" data-ps-name="${psName}" title="클릭하여 복사">${psName}</p>
                    <div class="mt-3 text-sm text-gray-600">
                        <span class="font-medium">Weight:</span> ${weight} | 
                        <span class="font-medium">Style:</span> ${style}
                    </div>
                `;
                postscriptListEl.appendChild(card);
            });

            // 동적으로 생성된 '복사' 버튼 및 텍스트에 이벤트 리스너 추가
            postscriptListEl.querySelectorAll('.copy-btn, .copy-text').forEach(el => {
                el.addEventListener('click', (e) => {
                    const nameToCopy = e.currentTarget.dataset.psName;
                    copyToClipboard(nameToCopy);
                });
            });
        }

        /**
         * 텍스트를 클립보드에 복사하는 함수
         * (iframe이나 로컬 파일 환경에서도 잘 작동하는 document.execCommand 사용)
         * @param {string} text - 복사할 텍스트
         */
        function copyToClipboard(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed'; // 화면에 보이지 않게 처리
            textarea.style.top = '-9999px';
            textarea.style.left = '-9999px';
            document.body.appendChild(textarea);
            textarea.focus();
    
            try {
                // 모바일 Safari 등에서 select()가 실패할 수 있으므로 setSelectionRange 사용
                textarea.setSelectionRange(0, textarea.value.length);
                const successful = document.execCommand('copy');
                
                if (successful) {
                    showToast(); // 복사 성공 알림
                } else {
                    alert('클립보드 복사에 실패했습니다.');
                }
            } catch (err) {
                console.error('클립보드 복사 실패:', err);
                alert('클립보드 복사에 실패했습니다.');
            } finally {
                document.body.removeChild(textarea); // 임시 요소 제거
            }
        }

        /**
         * 복사 성공 알림(Toast) 표시
         */
        let toastTimer;
        function showToast() {
            clearTimeout(toastTimer); // 이전 타이머 제거
            
            toastEl.classList.remove('opacity-0', 'translate-y-2');
            toastEl.classList.add('opacity-100', 'translate-y-0');

            toastTimer = setTimeout(() => {
                toastEl.classList.add('opacity-0', 'translate-y-2');
                toastEl.classList.remove('opacity-100', 'translate-y-0');
            }, 2000); // 2초 후 사라짐
        }

    </script>
</body>
</html>
